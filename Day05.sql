--DAY5

--CREATE : 객체 생성하는 DDL
--제약조건 : 테이블 생성 시 각 컬럼에 제한을 커는 조건.
--	NOT NULL, UNIQUE, CHECK, PRIMARY KEY, FOREIGN KEY

--생성된 테이블에 제약조건 추가하기
--테이블 수정한다.
--DDL의 ALTER 이용하여 추가

--[사용 형식]
--ALTER TABLE 테이블명 수정할 내용

--ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
--ALTER TABLE 테이블명 ADD FOREIGN KWY(컬럼명) REFERENCES 참조할 테이블명(컬럼명)
--ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
--ALTER TABLE 테이블명 ADD CHECK(조건식)
--ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

SELECT * FROM EMPLOYEE;

--EMPLOYEE테이블에 제약조건 추가
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE;

ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN ('Y','N'));

ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);

ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;

ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;


SELECT C1.TABLE_NAME, C1.CONSTRAINT_NAME, COLUMN_NAME, SEARCH_CONDITION, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN('EMPLOYEE','DEPARTMENT','LOCATION')
ORDER BY 1;

--제약조건 삭제 
--ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;


--DML(데이터 조작 언어)
--INSERT, UPDATE, DELETE, SELECT(DQL)--
--[CRUD]
--CREATE	: INSERT/데이터추가
--READ		: SELECT/데이터 조회
--UPDATE	: UPDATE/데이터 수정
--DELETE	: DELETE/데이터 삭제

--INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
--[사용형식]
--1. 특정 컬럼에만 값을 추가
--INSERT INTO 테이블명(컬럼명, 컬럼명,...) VLAUES(값, 값,...)

--2. 모든 컬럼에 값을 추가
--INSERT INTO 테이블명 VALUES(값, 값,...)

SELECT * FROM EMPLOYEE;

--INSERT 시 컬럼을 명시해서 데이터를 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES (500,'박태욱','001122-1234567','PARK123@MULTI.COM','01012345678','D1','J7','S4','3100000',0.1,'200',SYSDATE,NULL,DEFAULT);

COMMIT;

--INSERT 시 컬럼 생략하고 데이터 추가 -> 모든 컬럼에 값을 명시해주어야한다.
INSERT INTO EMPLOYEE
VALUES(900,'박서준','880101-1234567','SEOJ123@MULTI.COM','01022223333','D1','J7','S3',4300000,0.2,'200',SYSDATE,NULL,DEFAULT);
SELECT * FROM EMPLOYEE WHERE EMP_ID IN(500, 900);
COMMIT; --지금까지 변경된 내용을 DB에 반영(저장)하겠다.


--INSERT + SUBQUERY
CREATE TABLE EMP_01(
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);

SELECT * FROM EMP_01;

--기본
INSERT INTO EMP_01 VALUES(300,'박길동','총무부');


--SUBQUERY 활용
SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

INSERT INTO EMP_01 (SELECT EMP_ID, EMP_NAME, DEPT_TITLE
					FROM EMPLOYEE
					LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID));



DELETE FROM EMP_01;



CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE WHERE 1=2;

SELECT * FROM EMP_DEPT_D1;
--EMPLOYEE 테이블에서 D1부서에 근무하는 직원들의
--사번, 이름, 부서코드, 입사일을 조회하여 
--EMP_DEPT_D1테이블에 추가(INSERT)

INSERT INTO EMP_DEPT_D1 (SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE FROM EMPLOYEE WHERE DEPT_CODE = 'D1');




--UPDATE : 해당 테이블의 데이터를 수정하는 명령어
--[사용형식]
--UPDATE 테이블명 SET 컬럼명 = 변경값
--[WHERE 조건]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

--총무부 -> 전략기획부
UPDATE DEPT_COPY SET DEPT_TITLE = '전략기획부' WHERE DEPT_ID = 'D9';


--EMPLOYEE테이블에서 주민번호가 잘못 표기되어 있는 사원 수정하기
--'621230','631126','850707' 변경하는 UPDATE 구문 3개 작성

SELECT * FROM EMPLOYEE;


CREATE TABLE EMP_COPY4 AS SELECT * FROM EMPLOYEE;

UPDATE EMP_COPY4 SET EMP_NO = '621230-1985634' WHERE EMP_ID = 200;
UPDATE EMP_COPY4 SET EMP_NO = '631126-1985634' WHERE EMP_ID = 201;
UPDATE EMP_COPY4 SET EMP_NO = '850707-1985634' WHERE EMP_ID = 214;

SELECT * FROM EMP_COPY4;

UPDATE EMPlOYEE SET EMP_NO = '621230'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 200;
UPDATE EMPlOYEE SET EMP_NO = '631126'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 201;
UPDATE EMPlOYEE SET EMP_NO = '850707'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 214;

COMMIT;

UPDATE EMP_COPY4 SET DEPT_CODE = 'D3' WHERE JOB_CODE = 'J4';
SELECT * FROM EMP_COPY4;


--UPDATE + SUBQUERY
--여러 행을 변경하거나, 여러 컬럼 값을 변경하고자 할 때 서브쿼리 활용
--UPDATE 테이블명 SET 컬럼명 = (서브쿼리)

CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS FROM EMPLOYEE;

SELECT * FROM EMP_SALARY;

--사번 214인 사원의 보너스를
--사번 204인 사원의 보너스, 급여 같은 값으로 변경

SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204;
SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204;

UPDATE EMP_SALARY 
SET SALARY=(SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204), 
BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204) 
WHERE EMP_ID = 214;

SELECT * FROM EMP_SALARY WHERE EMP_ID IN(204,202,205,211,213);

--202, 205, 211, 213 사원들의 급여, 보너스도
--204사원과 동일하게 변경

UPDATE EMP_SALARY
SET SALARY=(SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204),
BONUS=(SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204)
WHERE EMP_ID IN(202,205,211,213);

--위와 동일
UPDATE EMP_SALARY
SET (SALARY,BONUS)=(SELECT SALARY, BONUS FROM EMP_SALARY WHERE EMP_ID = 204)
WHERE EMP_ID IN(202,205,211,213);


--UPDATE시 컬럼의 제약조건을 위배하지 않아야 한다.
UPDATE EMPLOYEE
SET DEPT_CODE = 'D0'
WHERE DEPT_CODE = 'D6';--에러

UPDATE EMP_ID = NULL WHERE EMP_ID = 200; --에러



SELECT * FROM EMPLOYEE WHERE ENT_YN = 'Y';
--222
UPDATE EMPLOYEE SET ENT_YN = DEFAULT WHERE EMP_ID = 222;


--DELETE--
--테이블에 행(ROW)을 삭제하는 명령어
--[사용형식]
--DELETE FROM 테이블명
--[WHERE 조건]
--WHERE가 없으면 테이블에 모든 데이터가 삭제

--DROP TABLE EMP; ==> 테이블 자체가 삭제된다.
--DELETE FROM EMP; ==> 테이블의 데이터만 삭제된다.

CREATE TABLE TEST_DELETE AS SELECT * FROM EMPLOYEE;

SELECT * FROM TEST_DELETE;

DELETE FROM DEPARTMENT WHERE DEPT_ID = 'D1'; -- 무결성 에러 - 자식레코드 있음


--제약조건 비활성화
--ALTER TABLE 테이블명 DISABLE CONSTRAINT 제약조건명;
--제약조건 활성화
--ALTER TABLE 테이블명 ENABLE CONSTRAINT 제약조건명;



--TRUNCATE 활용하여 전체 데이터 삭제
TRUNCATE TABLE TEST_DELETE;
--DELETE와 차이는 TRUNCATE는 ROLLBACK 불가능. 복구가 안됨
DELETE FROM TEST_DELETE;

SELECT * FROM TEST_DELETE;


--급여가 200이하로 받는 사원 삭제
DELETE FROM TEST_DELETE
WHERE SALARY<=2000000;


--COMMIT, ROLLBACK
--트랜잭션을 제어하는 명령어
--트랜잭션 : 데이터 처리하는 작업을 나눈 최소 단위
--하나의 트랜잭션을 이루어진 작업은 반드시 모두 성공 또는 모두 실패 처리되어야 한다.
--모두 성공 -> COMMIT;
--하나라도 실패하면 -> ROLLBACK;

--TCL(TRANSACTION CONTROL LANGUAGE)

/*
 * COMMNIT : 정상 종료 되었다면 변경된 사항을 영구적으로 DB에 반영
 * ROLLBACK : 트랜잭션 작업 중 문제가 발생하였을 경우 작업한 내역을 취소.
 * 
 * 
 * */


COMMIT;

DROP TABLE USER_TBL;

CREATE TABLE USER_TBL(
	 NO NUMBER UNIQUE,
	 ID VARCHAR2(20) NOT NULL UNIQUE,
	 PW VARCHAR2(30) NOT NULL
);

INSERT INTO USER_TBL VALUES(1,'TEST01','PASS01');
INSERT INTO USER_TBL VALUES(2,'TEST02','PASS02');

SELECT * FROM USER_TBL;

COMMIT;
--현대까지 작업한 DML 내용을 DB에 반영하겠다.

INSERT INTO USER_TBL VALUES(3,'TEST03','PASS03');

SELECT * FROM USER_TBL;

--잘못 입력했다.... 되돌리자
ROLLBACK;
--가장 최근에 커밋한 구간(상태)으로 돌아간다.
SELECT * FROM USER_TBL;

UPDATE USER_TBL SET ID = 'TEST1' WHERE NO=1;

--DELETE 문제 발생...


----
COMMIT;
INSERT INTO USER_TBL VALUES(3,'TEST03','PASS03');

SAVEPOINT SP1;
INSERT INTO USER_TBL VALUES(4,'TEST04','PASS04');
SELECT * FROM USER_TBL;
ROLLBACK TO SP1; --DBEAVER에서는 작동 안됨....
--해당 세이브포인트로 상태를 되돌린다.


-----
--DDL(CREATE. ALTER, DROP)

--ALTER
DROP TABLE DEPT_COPY;

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

--컬럼 추가
ALTER TABLE DEPT_COPY ADD(LNAME VARCHAR(20));

SELECT * FROM DEPT_COPY;

--컬럼 삭제
ALTER TABLE DEPT_COPY
DROP COLUMN LNAME;

SELECT * FROM DEPT_COPY;

--기본값 설정하여 컬럼 추가
ALTER TABLE DEPT_COPY
ADD(LNAME VARCHAR2(30) DEFAULT '한국');

SELECT * FROM DEPT_COPY;

CREATE TABLE DEPT_COPY2
AS SELECT * FROM DEPT_COPY;

SELECT * FROM DEPT_COPY2;
--DEPT_COPY테이블에서
--DEPT_ID에 기본키 제약조건
--DEPT_TITLE에 고유값
--LNAME에 필수 입력사항
-- 제약조건 추가

ALTER TABLE DEPT_COPY2 ADD CONSTRAINT PK_DEPT PRIMARY KEY(DEPT_ID);

ALTER TABLE DEPT_COPY2
ADD CONSTRAINT UK_DEPT_TITLE UNIQUE(DEPT_TITLE);

SELECT * FROM DEPT_COPY2;

ALTER TABLE DEPT_COPY2
MODIFY LNAME CONSTRAINT NN_DEPT_LNAME NOT NULL;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT_COPY2';


--컬럼의 자료형 수정

SELECT * FROM DEPT_COPY2;

ALTER TABLE DEPT_COPY2
MODIFY DEPT_ID CHAR(3);

ALTER TABLE DEPT_COPY2
MODIFY DEPT_TITLE VARCHAR2(50);

ALTER TABLE DEPT_COPY2
MODIFY LOCATION_ID VARCHAR2(2)
MODIFY LNAME CHAR(20); --여러개 한번에 처리 가능

--SQL Error [1441] [72000]: ORA-01441: 일부 값이 너무 커서 열 길이를 줄일 수 없음
ALTER TABLE DEPT_COPY2
MODIFY DEPT_TITLE VARCHAR2(5);

--컬럼의 이름 변경
ALTER TABLE DEPT_COPY2
RENAME COLUMN DEPT_TITLE TO DEPT_NAME;

SELECT * FROM DEPT_COPY2;

--테이블의 이름 변경
ALTER TABLE DEPT_COPY2
RENAME TO DEPT_COPY_TWO;

--SQL Error [942] [42000]: ORA-00942: 테이블 또는 뷰가 존재하지 않습니다
SELECT * FROM DEPT_COPY2;
SELECT * FROM DEPT_COPY_TWO;

--제약조건의 이름 변경
ALTER TABLE DEPT_COPY_TWO
RENAME CONSTRAINT PK_DEPT TO PK_DEPT_ID;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT_COPY_TWO';

ALTER TABLE DEPT_COPY_TWO
RENAME CONSTRAINT SYS_C007651 TO NN_LOC_ID;

RENAME DEPT_COPY_TWO TO DEPT_COPT2;

--SQL Error [942] [42000]: ORA-00942: 테이블 또는 뷰가 존재하지 않습니다
SELECT * FROM DEPT_COPY_TWO;

SELECT * FROM DEPT_COPT2;
RENAME DEPT_COPT2 TO DEPT_COPY2;--오타로 인해 한번 더 이름 바꿔줬음;;;..
SELECT * FROM DEPT_COPY2;


--제약조건 삭제
ALTER TABLE DEPT_COPY2 DROP CONSTRAINT NN_DEPT_LNAME;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT_COPY2';

ALTER TABLE DEPT_COPY2 DROP COLUMN LNAME;
SELECT * FROM DEPT_COPY2;

--DDL은 트랜잭션 개념이 아님. 
--COMMIT/ROLLBACK 불가.
--이전에 DML 실행 후 DDL실행하게 되면 
--이전까지 데이터 조작 내용이 자동으로 COMMIT처리

ALTER TABLE DEPT_COPY2 
DROP COLUMN LOCATION_ID;

ALTER TABLE DEPT_COPY2 
DROP COLUMN DEPT_NAME;

--SQL Error [12983] [72000]: ORA-12983: 테이블에 모든 열들을 삭제할 수 없습니다
ALTER TABLE DEPT_COPY2 
DROP COLUMN DEPT_ID;

--DROP
--객체 자체를 제거하거나  / DROP 객체 종류 객체명
--객체의 특정 요소를 제거하는 명령어/ ALTER 객체종류 객체명 DROP~~
--제약조건,컬럼

--테이블 삭제
DROP TABLE DEPT_COPY2;
--DROP VIEW 뷰이름;
--DROP USER 계정명;



----------------------------------------
--오라클 객체
--VIEW(뷰)
--SELECT를 실행한 결과 화면을 담는 객체.
--SELECT문장 자체를 저장한다고 생각하면 됨.
--호출핼 때마다 해당 쿼리를 실행하여 결과를 보여주는 객체

--[생성]
--CREATE [OR REPLACE] VIEW 뷰이름
--AS 서브쿼리(뷰를 통해 확인항 SELECT쿼리문)

--SELECT * FROM 뷰이름;

--현재 MULTI계정은 뷰를 만들 권한이 없다....

--권한 부여
--관리자 계정으로 접속하여 
--GRANT CREATE VIEW TO MULTI;

CREATE VIEW V_EMP
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE FROM EMPLOYEE;

SELECT * FROM V_EMP;

--생성한 뷰의 정보
SELECT * FROM USER_VIEWS;

--이미 생성된 뷰가 있어도, REPLACE를 통해 새로 생성이 가능하다.
CREATE OR REPLACE VIEW V_EMP(사번, 이름, 부서, 직급)
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE FROM EMPLOYEE;
--덮어씌우기 가능.

SELECT * FROM V_EMP;


--문제1.
--사번, 이름, 직급명, 부서명, 근무지역 조회 하는 쿼리문이 저장된 
--V_RESULTSET_EMP라는 이름의 뷰를 만들고,
--해당 뷰를 통해서 결과 조회하여 확인
SELECT * FROM EMPLOYEE;
SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;

CREATE VIEW V_RESULTSET_EMP 
AS SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING(JOB_CODE)
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
LEFT JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);

DROP VIEW V_RESULTSET_EMP;

SELECT * FROM V_RESULTSET_EMP;

SELECT * FROM V_RESULTSET_EMP
WHERE EMP_ID = 215;

--VIEW는 SELECT쿼리문을 저장하고 있기 때문에 
--원본 테이블의 값이 변경되면 뷰를 통해 확인하는 값들도 변경되어 확인된다.

UPDATE EMPLOYEE
SET EMP_NAME = '대브혼'
WHERE EMP_ID = 215;

--뷰 삭제
DROP VIEW V_RESULTSET_EMP;

--SQL Error [942] [42000]: ORA-00942: 테이블 또는 뷰가 존재하지 않습니다
SELECT * FROM V_RESULTSET_EMP;


--뷰 생성, 연산 결과를 뷰를 통해 확인

--1)서브쿼리 작성
SELECT EMP_ID, EMP_NAME,
	DECODE(SUBSTR(EMP_NO,8,1),2,'여성','남성'),
	EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
FROM EMPLOYEE;


--2)뷰 생성
CREATE OR REPLACE VIEW V_EMP(사번, 사원명, 성별, 근무년수)
AS
SELECT EMP_ID, EMP_NAME,
	DECODE(SUBSTR(EMP_NO,8,1),2,'여성','남성'),
	EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
FROM EMPLOYEE;

SELECT * FROM V_EMP;
















