--DAY5

--CREATE : 객체 생성하는 DDL
--제약조건 : 테이블 생성 시 각 컬럼에 제한을 커는 조건.
--	NOT NULL, UNIQUE, CHECK, PRIMARY KEY, FOREIGN KEY

--생성된 테이블에 제약조건 추가하기
--테이블 수정한다.
--DDL의 ALTER 이용하여 추가

--[사용 형식]
--ALTER TABLE 테이블명 수정할 내용

--ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
--ALTER TABLE 테이블명 ADD FOREIGN KWY(컬럼명) REFERENCES 참조할 테이블명(컬럼명)
--ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
--ALTER TABLE 테이블명 ADD CHECK(조건식)
--ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

SELECT * FROM EMPLOYEE;

--EMPLOYEE테이블에 제약조건 추가
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE;

ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN ('Y','N'));

ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);

ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;

ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;


SELECT C1.TABLE_NAME, C1.CONSTRAINT_NAME, COLUMN_NAME, SEARCH_CONDITION, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN('EMPLOYEE','DEPARTMENT','LOCATION')
ORDER BY 1;

--제약조건 삭제 
--ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;


--DML(데이터 조작 언어)
--INSERT, UPDATE, DELETE, SELECT(DQL)--
--[CRUD]
--CREATE	: INSERT/데이터추가
--READ		: SELECT/데이터 조회
--UPDATE	: UPDATE/데이터 수정
--DELETE	: DELETE/데이터 삭제

--INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
--[사용형식]
--1. 특정 컬럼에만 값을 추가
--INSERT INTO 테이블명(컬럼명, 컬럼명,...) VLAUES(값, 값,...)

--2. 모든 컬럼에 값을 추가
--INSERT INTO 테이블명 VALUES(값, 값,...)

SELECT * FROM EMPLOYEE;

--INSERT 시 컬럼을 명시해서 데이터를 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES (500,'박태욱','001122-1234567','PARK123@MULTI.COM','01012345678','D1','J7','S4','3100000',0.1,'200',SYSDATE,NULL,DEFAULT);

COMMIT;

--INSERT 시 컬럼 생략하고 데이터 추가 -> 모든 컬럼에 값을 명시해주어야한다.
INSERT INTO EMPLOYEE
VALUES(900,'박서준','880101-1234567','SEOJ123@MULTI.COM','01022223333','D1','J7','S3',4300000,0.2,'200',SYSDATE,NULL,DEFAULT);
SELECT * FROM EMPLOYEE WHERE EMP_ID IN(500, 900);
COMMIT; --지금까지 변경된 내용을 DB에 반영(저장)하겠다.


--INSERT + SUBQUERY
CREATE TABLE EMP_01(
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);

SELECT * FROM EMP_01;

--기본
INSERT INTO EMP_01 VALUES(300,'박길동','총무부');


--SUBQUERY 활용
SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

INSERT INTO EMP_01 (SELECT EMP_ID, EMP_NAME, DEPT_TITLE
					FROM EMPLOYEE
					LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID));



DELETE FROM EMP_01;



CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE WHERE 1=2;

SELECT * FROM EMP_DEPT_D1;
--EMPLOYEE 테이블에서 D1부서에 근무하는 직원들의
--사번, 이름, 부서코드, 입사일을 조회하여 
--EMP_DEPT_D1테이블에 추가(INSERT)

INSERT INTO EMP_DEPT_D1 (SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE FROM EMPLOYEE WHERE DEPT_CODE = 'D1');




--UPDATE : 해당 테이블의 데이터를 수정하는 명령어
--[사용형식]
--UPDATE 테이블명 SET 컬럼명 = 변경값
--[WHERE 조건]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

--총무부 -> 전략기획부
UPDATE DEPT_COPY SET DEPT_TITLE = '전략기획부' WHERE DEPT_ID = 'D9';


--EMPLOYEE테이블에서 주민번호가 잘못 표기되어 있는 사원 수정하기
--'621230','631126','850707' 변경하는 UPDATE 구문 3개 작성

SELECT * FROM EMPLOYEE;


CREATE TABLE EMP_COPY4 AS SELECT * FROM EMPLOYEE;

UPDATE EMP_COPY4 SET EMP_NO = '621230-1985634' WHERE EMP_ID = 200;
UPDATE EMP_COPY4 SET EMP_NO = '631126-1985634' WHERE EMP_ID = 201;
UPDATE EMP_COPY4 SET EMP_NO = '850707-1985634' WHERE EMP_ID = 214;

SELECT * FROM EMP_COPY4;

UPDATE EMPlOYEE SET EMP_NO = '621230'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 200;
UPDATE EMPlOYEE SET EMP_NO = '631126'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 201;
UPDATE EMPlOYEE SET EMP_NO = '850707'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 214;

COMMIT;

UPDATE EMP_COPY4 SET DEPT_CODE = 'D3' WHERE JOB_CODE = 'J4';
SELECT * FROM EMP_COPY4;


--UPDATE + SUBQUERY
--여러 행을 변경하거나, 여러 컬럼 값을 변경하고자 할 때 서브쿼리 활용
--UPDATE 테이블명 SET 컬럼명 = (서브쿼리)

CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS FROM EMPLOYEE;

SELECT * FROM EMP_SALARY;

--사번 214인 사원의 보너스를
--사번 204인 사원의 보너스, 급여 같은 값으로 변경

SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204;
SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204;

UPDATE EMP_SALARY 
SET SALARY=(SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204), 
BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204) 
WHERE EMP_ID = 214;

SELECT * FROM EMP_SALARY WHERE EMP_ID IN(204,202,205,211,213);

--202, 205, 211, 213 사원들의 급여, 보너스도
--204사원과 동일하게 변경

UPDATE EMP_SALARY
SET SALARY=(SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204),
BONUS=(SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204)
WHERE EMP_ID IN(202,205,211,213);

--위와 동일
UPDATE EMP_SALARY
SET (SALARY,BONUS)=(SELECT SALARY, BONUS FROM EMP_SALARY WHERE EMP_ID = 204)
WHERE EMP_ID IN(202,205,211,213);


--UPDATE시 컬럼의 제약조건을 위배하지 않아야 한다.
UPDATE EMPLOYEE
SET DEPT_CODE = 'D0'
WHERE DEPT_CODE = 'D6';--에러

UPDATE EMP_ID = NULL WHERE EMP_ID = 200; --에러



SELECT * FROM EMPLOYEE WHERE ENT_YN = 'Y';
--222
UPDATE EMPLOYEE SET ENT_YN = DEFAULT WHERE EMP_ID = 222;


--DELETE--
--테이블에 행(ROW)을 삭제하는 명령어
--[사용형식]
--DELETE FROM 테이블명
--[WHERE 조건]
--WHERE가 없으면 테이블에 모든 데이터가 삭제

--DROP TABLE EMP; ==> 테이블 자체가 삭제된다.
--DELETE FROM EMP; ==> 테이블의 데이터만 삭제된다.

CREATE TABLE TEST_DELETE AS SELECT * FROM EMPLOYEE;

SELECT * FROM TEST_DELETE;

DELETE FROM DEPARTMENT WHERE DEPT_ID = 'D1'; -- 무결성 에러 - 자식레코드 있음


--제약조건 비활성화
--ALTER TABLE 테이블명 DISABLE CONSTRAINT 제약조건명;
--제약조건 활성화
--ALTER TABLE 테이블명 ENABLE CONSTRAINT 제약조건명;



--TRUNCATE 활용하여 전체 데이터 삭제
TRUNCATE TABLE TEST_DELETE;
--DELETE와 차이는 TRUNCATE는 ROLLBACK 불가능. 복구가 안됨
DELETE FROM TEST_DELETE;

SELECT * FROM TEST_DELETE;


--급여가 200이하로 받는 사원 삭제
DELETE FROM TEST_DELETE
WHERE SALARY<=2000000;


--COMMIT, ROLLBACK
--트랜잭션을 제어하는 명령어
--트랜잭션 : 데이터 처리하는 작업을 나눈 최소 단위
--하나의 트랜잭션을 이루어진 작업은 반드시 모두 성공 또는 모두 실패 처리되어야 한다.
--모두 성공 -> COMMIT;
--하나라도 실패하면 -> ROLLBACK;

--TCL(TRANSACTION CONTROL LANGUAGE)




























