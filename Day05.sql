--DAY5

--CREATE : 객체 생성하는 DDL
--제약조건 : 테이블 생성 시 각 컬럼에 제한을 커는 조건.
--	NOT NULL, UNIQUE, CHECK, PRIMARY KEY, FOREIGN KEY

--생성된 테이블에 제약조건 추가하기
--테이블 수정한다.
--DDL의 ALTER 이용하여 추가

--[사용 형식]
--ALTER TABLE 테이블명 수정할 내용

--ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
--ALTER TABLE 테이블명 ADD FOREIGN KWY(컬럼명) REFERENCES 참조할 테이블명(컬럼명)
--ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
--ALTER TABLE 테이블명 ADD CHECK(조건식)
--ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

SELECT * FROM EMPLOYEE;

--EMPLOYEE테이블에 제약조건 추가
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB;

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE;

ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN ('Y','N'));

ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);

ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;

ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;


SELECT C1.TABLE_NAME, C1.CONSTRAINT_NAME, COLUMN_NAME, SEARCH_CONDITION, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN('EMPLOYEE','DEPARTMENT','LOCATION')
ORDER BY 1;

--제약조건 삭제 
--ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;


--DML(데이터 조작 언어)
--INSERT, UPDATE, DELETE, SELECT(DQL)--
--[CRUD]
--CREATE	: INSERT/데이터추가
--READ		: SELECT/데이터 조회
--UPDATE	: UPDATE/데이터 수정
--DELETE	: DELETE/데이터 삭제

--INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
--[사용형식]
--1. 특정 컬럼에만 값을 추가
--INSERT INTO 테이블명(컬럼명, 컬럼명,...) VLAUES(값, 값,...)

--2. 모든 컬럼에 값을 추가
--INSERT INTO 테이블명 VALUES(값, 값,...)

SELECT * FROM EMPLOYEE;

--INSERT 시 컬럼을 명시해서 데이터를 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES (500,'박태욱','001122-1234567','PARK123@MULTI.COM','01012345678','D1','J7','S4','3100000',0.1,'200',SYSDATE,NULL,DEFAULT);

COMMIT;

--INSERT 시 컬럼 생략하고 데이터 추가 -> 모든 컬럼에 값을 명시해주어야한다.
INSERT INTO EMPLOYEE
VALUES(900,'박서준','880101-1234567','SEOJ123@MULTI.COM','01022223333','D1','J7','S3',4300000,0.2,'200',SYSDATE,NULL,DEFAULT);
SELECT * FROM EMPLOYEE WHERE EMP_ID IN(500, 900);
COMMIT; --지금까지 변경된 내용을 DB에 반영(저장)하겠다.


--INSERT + SUBQUERY
CREATE TABLE EMP_01(
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);

SELECT * FROM EMP_01;

--기본
INSERT INTO EMP_01 VALUES(300,'박길동','총무부');


--SUBQUERY 활용
SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

INSERT INTO EMP_01 (SELECT EMP_ID, EMP_NAME, DEPT_TITLE
					FROM EMPLOYEE
					LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID));



DELETE FROM EMP_01;



CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE WHERE 1=2;

SELECT * FROM EMP_DEPT_D1;
--EMPLOYEE 테이블에서 D1부서에 근무하는 직원들의
--사번, 이름, 부서코드, 입사일을 조회하여 
--EMP_DEPT_D1테이블에 추가(INSERT)

INSERT INTO EMP_DEPT_D1 (SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE FROM EMPLOYEE WHERE DEPT_CODE = 'D1');




--UPDATE : 해당 테이블의 데이터를 수정하는 명령어
--[사용형식]
--UPDATE 테이블명 SET 컬럼명 = 변경값
--[WHERE 조건]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

--총무부 -> 전략기획부
UPDATE DEPT_COPY SET DEPT_TITLE = '전략기획부' WHERE DEPT_ID = 'D9';


--EMPLOYEE테이블에서 주민번호가 잘못 표기되어 있는 사원 수정하기
--'621230','631126','850707' 변경하는 UPDATE 구문 3개 작성

SELECT * FROM EMPLOYEE;


CREATE TABLE EMP_COPY4 AS SELECT * FROM EMPLOYEE;

UPDATE EMP_COPY4 SET EMP_NO = '621230-1985634' WHERE EMP_ID = 200;
UPDATE EMP_COPY4 SET EMP_NO = '631126-1985634' WHERE EMP_ID = 201;
UPDATE EMP_COPY4 SET EMP_NO = '850707-1985634' WHERE EMP_ID = 214;

SELECT * FROM EMP_COPY4;

UPDATE EMPlOYEE SET EMP_NO = '621230'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 200;
UPDATE EMPlOYEE SET EMP_NO = '631126'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 201;
UPDATE EMPlOYEE SET EMP_NO = '850707'||SUBSTR(EMP_NO,7) WHERE EMP_ID = 214;

COMMIT;

UPDATE EMP_COPY4 SET DEPT_CODE = 'D3' WHERE JOB_CODE = 'J4';
SELECT * FROM EMP_COPY4;


--UPDATE + SUBQUERY
--여러 행을 변경하거나, 여러 컬럼 값을 변경하고자 할 때 서브쿼리 활용
--UPDATE 테이블명 SET 컬럼명 = (서브쿼리)

CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS FROM EMPLOYEE;

SELECT * FROM EMP_SALARY;

--사번 214인 사원의 보너스를
--사번 204인 사원의 보너스, 급여 같은 값으로 변경

SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204;
SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204;

UPDATE EMP_SALARY 
SET SALARY=(SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204), 
BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204) 
WHERE EMP_ID = 214;

SELECT * FROM EMP_SALARY WHERE EMP_ID IN(204,202,205,211,213);

--202, 205, 211, 213 사원들의 급여, 보너스도
--204사원과 동일하게 변경

UPDATE EMP_SALARY
SET SALARY=(SELECT SALARY FROM EMP_SALARY WHERE EMP_ID = 204),
BONUS=(SELECT BONUS FROM EMP_SALARY WHERE EMP_ID = 204)
WHERE EMP_ID IN(202,205,211,213);

--위와 동일
UPDATE EMP_SALARY
SET (SALARY,BONUS)=(SELECT SALARY, BONUS FROM EMP_SALARY WHERE EMP_ID = 204)
WHERE EMP_ID IN(202,205,211,213);


--UPDATE시 컬럼의 제약조건을 위배하지 않아야 한다.
UPDATE EMPLOYEE
SET DEPT_CODE = 'D0'
WHERE DEPT_CODE = 'D6';--에러

UPDATE EMP_ID = NULL WHERE EMP_ID = 200; --에러



SELECT * FROM EMPLOYEE WHERE ENT_YN = 'Y';
--222
UPDATE EMPLOYEE SET ENT_YN = DEFAULT WHERE EMP_ID = 222;


--DELETE--
--테이블에 행(ROW)을 삭제하는 명령어
--[사용형식]
--DELETE FROM 테이블명
--[WHERE 조건]
--WHERE가 없으면 테이블에 모든 데이터가 삭제

--DROP TABLE EMP; ==> 테이블 자체가 삭제된다.
--DELETE FROM EMP; ==> 테이블의 데이터만 삭제된다.

CREATE TABLE TEST_DELETE AS SELECT * FROM EMPLOYEE;

SELECT * FROM TEST_DELETE;

DELETE FROM DEPARTMENT WHERE DEPT_ID = 'D1'; -- 무결성 에러 - 자식레코드 있음


--제약조건 비활성화
--ALTER TABLE 테이블명 DISABLE CONSTRAINT 제약조건명;
--제약조건 활성화
--ALTER TABLE 테이블명 ENABLE CONSTRAINT 제약조건명;



--TRUNCATE 활용하여 전체 데이터 삭제
TRUNCATE TABLE TEST_DELETE;
--DELETE와 차이는 TRUNCATE는 ROLLBACK 불가능. 복구가 안됨
DELETE FROM TEST_DELETE;

SELECT * FROM TEST_DELETE;


--급여가 200이하로 받는 사원 삭제
DELETE FROM TEST_DELETE
WHERE SALARY<=2000000;


--COMMIT, ROLLBACK
--트랜잭션을 제어하는 명령어
--트랜잭션 : 데이터 처리하는 작업을 나눈 최소 단위
--하나의 트랜잭션을 이루어진 작업은 반드시 모두 성공 또는 모두 실패 처리되어야 한다.
--모두 성공 -> COMMIT;
--하나라도 실패하면 -> ROLLBACK;

--TCL(TRANSACTION CONTROL LANGUAGE)

/*
 * COMMNIT : 정상 종료 되었다면 변경된 사항을 영구적으로 DB에 반영
 * ROLLBACK : 트랜잭션 작업 중 문제가 발생하였을 경우 작업한 내역을 취소.
 * 
 * 
 * */


COMMIT;

DROP TABLE USER_TBL;

CREATE TABLE USER_TBL(
	 NO NUMBER UNIQUE,
	 ID VARCHAR2(20) NOT NULL UNIQUE,
	 PW VARCHAR2(30) NOT NULL
);

INSERT INTO USER_TBL VALUES(1,'TEST01','PASS01');
INSERT INTO USER_TBL VALUES(2,'TEST02','PASS02');

SELECT * FROM USER_TBL;

COMMIT;
--현대까지 작업한 DML 내용을 DB에 반영하겠다.

INSERT INTO USER_TBL VALUES(3,'TEST03','PASS03');

SELECT * FROM USER_TBL;

--잘못 입력했다.... 되돌리자
ROLLBACK;
--가장 최근에 커밋한 구간(상태)으로 돌아간다.
SELECT * FROM USER_TBL;

UPDATE USER_TBL SET ID = 'TEST1' WHERE NO=1;

--DELETE 문제 발생...


----
COMMIT;
INSERT INTO USER_TBL VALUES(3,'TEST03','PASS03');

SAVEPOINT SP1;
INSERT INTO USER_TBL VALUES(4,'TEST04','PASS04');
SELECT * FROM USER_TBL;
ROLLBACK TO SP1; --DBEAVER에서는 작동 안됨....
--해당 세이브포인트로 상태를 되돌린다.


-----
--DDL(CREATE. ALTER, DROP)

--ALTER
DROP TABLE DEPT_COPY;

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

--컬럼 추가
ALTER TABLE DEPT_COPY ADD(LNAME VARCHAR(20));

SELECT * FROM DEPT_COPY;

--컬럼 삭제
ALTER TABLE DEPT_COPY
DROP COLUMN LNAME;

SELECT * FROM DEPT_COPY;

--기본값 설정하여 컬럼 추가
ALTER TABLE DEPT_COPY
ADD(LNAME VARCHAR2(30) DEFAULT '한국');

SELECT * FROM DEPT_COPY;

CREATE TABLE DEPT_COPY2
AS SELECT * FROM DEPT_COPY;

SELECT * FROM DEPT_COPY2;
--DEPT_COPY테이블에서
--DEPT_ID에 기본키 제약조건
--DEPT_TITLE에 고유값
--LNAME에 필수 입력사항
-- 제약조건 추가

ALTER TABLE DEPT_COPY2 ADD CONSTRAINT PK_DEPT PRIMARY KEY(DEPT_ID);

ALTER TABLE DEPT_COPY2
ADD CONSTRAINT UK_DEPT_TITLE UNIQUE(DEPT_TITLE);

SELECT * FROM DEPT_COPY2;

ALTER TABLE DEPT_COPY2
MODIFY LNAME CONSTRAINT NN_DEPT_LNAME NOT NULL;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT_COPY2';


--컬럼의 자료형 수정

SELECT * FROM DEPT_COPY2;

ALTER TABLE DEPT_COPY2
MODIFY DEPT_ID CHAR(3);

ALTER TABLE DEPT_COPY2
MODIFY DEPT_TITLE VARCHAR2(50);

ALTER TABLE DEPT_COPY2
MODIFY LOCATION_ID VARCHAR2(2)
MODIFY LNAME CHAR(20); --여러개 한번에 처리 가능

--SQL Error [1441] [72000]: ORA-01441: 일부 값이 너무 커서 열 길이를 줄일 수 없음
ALTER TABLE DEPT_COPY2
MODIFY DEPT_TITLE VARCHAR2(5);

--컬럼의 이름 변경
ALTER TABLE DEPT_COPY2
RENAME COLUMN DEPT_TITLE TO DEPT_NAME;

SELECT * FROM DEPT_COPY2;

--테이블의 이름 변경
ALTER TABLE DEPT_COPY2
RENAME TO DEPT_COPY_TWO;

--SQL Error [942] [42000]: ORA-00942: 테이블 또는 뷰가 존재하지 않습니다
SELECT * FROM DEPT_COPY2;
SELECT * FROM DEPT_COPY_TWO;

--제약조건의 이름 변경
ALTER TABLE DEPT_COPY_TWO
RENAME CONSTRAINT PK_DEPT TO PK_DEPT_ID;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT_COPY_TWO';

ALTER TABLE DEPT_COPY_TWO
RENAME CONSTRAINT SYS_C007651 TO NN_LOC_ID;

RENAME DEPT_COPY_TWO TO DEPT_COPT2;

--SQL Error [942] [42000]: ORA-00942: 테이블 또는 뷰가 존재하지 않습니다
SELECT * FROM DEPT_COPY_TWO;

SELECT * FROM DEPT_COPT2;
RENAME DEPT_COPT2 TO DEPT_COPY2;--오타로 인해 한번 더 이름 바꿔줬음;;;..
SELECT * FROM DEPT_COPY2;


--제약조건 삭제
ALTER TABLE DEPT_COPY2 DROP CONSTRAINT NN_DEPT_LNAME;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPT_COPY2';

ALTER TABLE DEPT_COPY2 DROP COLUMN LNAME;
SELECT * FROM DEPT_COPY2;

--DDL은 트랜잭션 개념이 아님. 
--COMMIT/ROLLBACK 불가.
--이전에 DML 실행 후 DDL실행하게 되면 
--이전까지 데이터 조작 내용이 자동으로 COMMIT처리

ALTER TABLE DEPT_COPY2 
DROP COLUMN LOCATION_ID;

ALTER TABLE DEPT_COPY2 
DROP COLUMN DEPT_NAME;

--SQL Error [12983] [72000]: ORA-12983: 테이블에 모든 열들을 삭제할 수 없습니다
ALTER TABLE DEPT_COPY2 
DROP COLUMN DEPT_ID;

--DROP
--객체 자체를 제거하거나  / DROP 객체 종류 객체명
--객체의 특정 요소를 제거하는 명령어/ ALTER 객체종류 객체명 DROP~~
--제약조건,컬럼

--테이블 삭제
DROP TABLE DEPT_COPY2;
--DROP VIEW 뷰이름;
--DROP USER 계정명;



----------------------------------------
--오라클 객체
--VIEW(뷰)
--SELECT를 실행한 결과 화면을 담는 객체.
--SELECT문장 자체를 저장한다고 생각하면 됨.
--호출핼 때마다 해당 쿼리를 실행하여 결과를 보여주는 객체

--[생성]
--CREATE [OR REPLACE] VIEW 뷰이름
--AS 서브쿼리(뷰를 통해 확인항 SELECT쿼리문)

--SELECT * FROM 뷰이름;

--현재 MULTI계정은 뷰를 만들 권한이 없다....

--권한 부여
--관리자 계정으로 접속하여 
--GRANT CREATE VIEW TO MULTI;

CREATE VIEW V_EMP
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE FROM EMPLOYEE;

SELECT * FROM V_EMP;

--생성한 뷰의 정보
SELECT * FROM USER_VIEWS;

--이미 생성된 뷰가 있어도, REPLACE를 통해 새로 생성이 가능하다.
CREATE OR REPLACE VIEW V_EMP(사번, 이름, 부서, 직급)
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE FROM EMPLOYEE;
--덮어씌우기 가능.

SELECT * FROM V_EMP;


--문제1.
--사번, 이름, 직급명, 부서명, 근무지역 조회 하는 쿼리문이 저장된 
--V_RESULTSET_EMP라는 이름의 뷰를 만들고,
--해당 뷰를 통해서 결과 조회하여 확인
SELECT * FROM EMPLOYEE;
SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;

CREATE VIEW V_RESULTSET_EMP 
AS SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING(JOB_CODE)
LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
LEFT JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);

DROP VIEW V_RESULTSET_EMP;

SELECT * FROM V_RESULTSET_EMP;

SELECT * FROM V_RESULTSET_EMP
WHERE EMP_ID = 215;

--VIEW는 SELECT쿼리문을 저장하고 있기 때문에 
--원본 테이블의 값이 변경되면 뷰를 통해 확인하는 값들도 변경되어 확인된다.

UPDATE EMPLOYEE
SET EMP_NAME = '대브혼'
WHERE EMP_ID = 215;

--뷰 삭제
DROP VIEW V_RESULTSET_EMP;

--SQL Error [942] [42000]: ORA-00942: 테이블 또는 뷰가 존재하지 않습니다
SELECT * FROM V_RESULTSET_EMP;


--뷰 생성, 연산 결과를 뷰를 통해 확인

--1)서브쿼리 작성
SELECT EMP_ID, EMP_NAME,
	DECODE(SUBSTR(EMP_NO,8,1),2,'여성','남성'),
	EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
FROM EMPLOYEE;


--2)뷰 생성
CREATE OR REPLACE VIEW V_EMP(사번, 사원명, 성별, 근무년수)
AS
SELECT EMP_ID, EMP_NAME,
	DECODE(SUBSTR(EMP_NO,8,1),2,'여성','남성'),
	EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
FROM EMPLOYEE;

SELECT * FROM V_EMP;


--뷰를 이용해서 기본적인 데이터 삽입, 수정, 삭제는 가능하다. 제한적이지만...
CREATE OR REPLACE VIEW V_JOB
AS SELECT * FROM JOB;

SELECT * FROM V_JOB;

--데이터 추가
INSERT INTO V_JOB
VALUES('J8','인턴');

SELECT * FROM V_JOB;
SELECT * FROM JOB;
--뷰는 물론 원본 테이블에도 추가 잘 됨.


--데이터 수정
UPDATE V_JOB
SET JOB_NAME = '아르바이트'
WHERE JOB_CODE = 'J8';

SELECT * FROM V_JOB;
SELECT * FROM JOB;
--둘다 잘 바뀐다.


--데이터 삭제
DELETE FROM V_JOB
WHERE JOB_CODE = 'J8';

SELECT * FROM V_JOB;
SELECT * FROM JOB;
--삭제도 잘 된다.

--불가능한 경우
--1. 뷰에 정의되지(뷰를 통해 확인 할 수 있는 컬럼) 않은 컬럼일 경우
--2. 산술 연산이 적용된 컬럼일 경우
--3. JOIN을 통해 여러 테이블을 참조할 경우 
--4. 그룹함수, GROUP BY구문 사용할 경우

CREATE OR REPLACE VIEW V_EMP_SAL
AS
SELECT EMP_ID, EMP_NAME, SALARY,(SALARY*12) 연봉
FROM EMPLOYEE;

SELECT * FROM V_EMP_SAL;

--SQL Error [1733] [42000]: ORA-01733: 가상 열은 사용할 수 없습니다
INSERT INTO V_EMP_SAL
VALUES(900,'김보성',3000000,12000000);


CREATE OR REPLACE VIEW V_JOB
AS
SELECT JOB_CODE FROM JOB;

SELECT * FROM V_JOB;

--SQL Error [913] [42000]: ORA-00913: 값의 수가 너무 많습니다
INSERT INTO V_JOB VALUES('J8','인턴');

INSERT INTO V_JOB VALUES('J8');

SELECT * FROM V_JOB;
SELECT * FROM JOB;

DELETE FROM JOB WHERE JOB_CODE = 'J8';

--VIEW 생성 시 설정 가능 옵션들
--OR REPLACE : 기존에 있던 동일한 이름의 뷰가 있을 떈 덮어씌어 생성, 없다면 새로 생성
--FORCE/NO FORCE : 서브쿼리에 사용된 테이블 없어도 뷰를 강제로 생성할 것인지 설정.
--WITH CHECK / READ ONLY : 
--				CHECK : 옵션을 설정한 컬럼의 값을 바꾸지 못하게 하는 설정
--				READ ONLY : 뷰에 사용된 어떠한 컬럼도 뷰를 통해 변경하지 못하게 막는 설정

--FORCE
CREATE OR REPLACE FORCE VIEW V_EMP --일단 뷰는 만들어는 둠...
AS
SELECT T_CODE, T_NAME, T_CONTENT
FROM TEST_TABLE;

SELECT * FROM V_EMP; --만들어는 지지만, 불러오면 문제가 생김. 

DROP VIEW V_EMP;


CREATE OR REPLACE /*NOFORCE*/ VIEW V_EMP --생성 안됨.NOFORCE는 기본값.
AS
SELECT T_CODE, T_NAME, T_CONTENT
FROM TEST_TABLE;



--WITH CHECK : 뷰에 존재하는 컬럼을 통해 추가나 수정 작업을 하지 못하게 막는 옵션. 삭제는 가능.
CREATE OR REPLACE VIEW V_EMP
AS SELECT * FROM EMPLOYEE
WITH CHECK OPTION;

SELECT * FROM V_EMP;

--SQL Error [32575] [99999]: ORA-32575: 뷰를 수정하는데 명시적 열 기본값이 지원되지 않음 -> WITH CHECK OPTION 때문임.
INSERT INTO V_EMP VALUES (800,'이동진','010101-1234567','LEE52@MULTI.COM','01055556666','D1','J7','S1',8000000,0.2,201,SYSDATE,NULL,DEFAULT);

INSERT INTO EMPLOYEE VALUES (800,'이동진','010101-1234567','LEE52@MULTI.COM','01055556666','D1','J7','S1',8000000,0.2,201,SYSDATE,NULL,DEFAULT);
SELECT * FROM EMPLOYEE;
DELETE FROM EMPLOYEE WHERE EMP_ID = 800;

---WITH CHECK는 DELETE는 가능
DELETE FROM V_EMP WHERE EMP_ID=800;
SELECT * FROM EMPLOYEE;


--- WITH REWAD ONLY : 입력, 수정, 삭제 모두 막는 옵션
CREATE OR REPLACE VIEW V_EMP
AS SELECT * FROM EMPLOYEE
WITH READ ONLY;

SELECT * FROM V_EMP;

--SQL Error [32575] [99999]: ORA-32575: 뷰를 수정하는데 명시적 열 기본값이 지원되지 않음
INSERT INTO V_EMP VALUES (800,'이동진','010101-1234567','LEE52@MULTI.COM','01055556666','D1','J7','S1',8000000,0.2,201,SYSDATE,NULL,DEFAULT);

--SQL Error [42399] [99999]: ORA-42399: 읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다.
DELETE FROM V_EMP WHERE EMP_ID = 900; -- 삭제도 안됨.



--SEQUENCE 시퀀스
--1,2,3,4,5..의 형식으로 숫자데이터를 자동으로 카운트 하는 객체


--CREATE SEQUENCE 시퀀스명
--[INCREAMENT BY 숫자] : 다음 값에 대한 증감 수치, 5:5씩 증가, -5:5씩 감소
--[START WITH 숫자] 	: 시작값
--[MAXVALUE 숫자] 	: 발생시킬 최대값 설정
--[MINVALUE 숫자] 	: 발생시킬 최솟값 설정
--[CYCLE | NOCYCLE] : 값의 순환 여부
--[CACHE 바이트크기 | NOCACHE] : 값을 미리 구하여 놓고, 다음 값을 반영할 때 활용하는 설정


CREATE SEQUENCE SEQ_EMPID
START WITH 300
INCREMENT BY 5
MAXVALUE 310
NOCYCLE
NOCACHE;

--SQL Error [8004] [72000]: ORA-08004: 시퀀스 SEQ_EMPID.NEXTVAL exceeds MAXVALUE은 사례로 될 수 없습니다
--300,305,310 값을 실행할 때마다 확인. 310을 넘어가는 순간 에러가 뜬다.
SELECT SEQ_EMPID.NEXTVAL FROM DUAL;
SELECT SEQ_EMPID.CURRVAL FROM DUAL;

--시퀀스 수정 : **시퀀스를 수정할 때 초기값을 바꿀 순 없다.** -> 다시 만들어야됨.
ALTER SEQUENCE SEQ_EMPID
INCREMENT BY 10
MAXVALUE 400
NOCYCLE
NOCACHE;

--10씩 증가하다가 400 넘어가면 에러.
SELECT SEQ_EMPID.NEXTVAL FROM DUAL;

SELECT * FROM USER_SEQUENCES;

--SELECT, INSERT, UPDATE 등에서 사용가능
--단, 서브쿼리의 SELECT문, VIEW, DISTINCT 사용한 컬럼 등과는 함께 사용 불가능
--GROUP BY, HAVING, ORDER BY 에서도 사용 불가
--CREATE TABLE시, ALTER TABLE시 컬럼의 기본값 선언에 사용할 수 없다.

--삭제하기
DROP SEQUENCE SEQ_EMPID; --시퀀스가 삭제된다.

--시퀀스를 이용하여 데이터 추가
CREATE SEQUENCE SEQ_EID
START WITH 300
MAXVALUE 10000
NOCYCLE
NOCACHE;
--INCREMENT BY 1 --1은 생략해도 됨.

SELECT * FROM USER_SEQUENCES;

--데이터 추가
INSERT INTO EMPLOYEE VALUES(SEQ_EID.NEXTVAL, '비타민','121203-1234567','VI_TM@MULTI.COM','01044443333','D2','J7','S1',5000000,0.2,201,SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME = '비타민';


--D9부서에 J7직급 사원 4명을 
--시퀀스를 사용해서 임의로 추가.

INSERT INTO EMPLOYEE VALUES(SEQ_EID.NEXTVAL, '양세찬','111212-1234567','YSC123@MULTI.COM','01055556666','D9','J7','S1',6000000,0.2,200,SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE;

INSERT INTO EMPLOYEE VALUES(SEQ_EID.NEXTVAL, '갤럭시','060504-1234567','GLX123@MULTI.COM','01055556666','D9','J7','S1',3000000,0.2,201,SYSDATE,NULL,DEFAULT);

INSERT INTO EMPLOYEE VALUES(SEQ_EID.NEXTVAL, '오미자','121110-1234567','OMJ123@MULTI.COM','01088664455','D9','J7','S1',4000000,0.2,200,SYSDATE,NULL,DEFAULT);

