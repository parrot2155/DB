--DAY06

--시퀀스 옵션 CYCLE/CACHE
CREATE SEQUENCE SEQ_CYCLE
START WITH 200
INCREMENT BY 10
MAXVALUE 230
MINVALUE 15
CYCLE
NOCACHE;

SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;
SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;
SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;
SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;

SELECT * FROM USER_SEQUENCES;

--CACHE / NOCACHE
--컴퓨터가 다음 값에 대한 연산들을 미리 계산해 놓은것

CREATE SEQUENCE SEQ_CACHE
START WITH 100
CACHE 20
NOCYCLE;


CREATE SEQUENCE SEQ_NOCACHE
START WITH 100
NOCACHE
NOCYCLE;

SELECT * FROM USER_SEQUENCES WHERE SEQUENCE_NAME LIKE '%CACHE';

SELECT SEQ_CACHE.NEXTVAL, SEQ_NOCACHE.NEXTVAL
FROM DUAL;


--INDEX--
--SQL 명령어 조회처리 속도를 향상시키기 위한 객체

--장점 : 검색 속도 향상
--단점 : 만약 테이블 내용이 자주 변경되는 테이블이라면 
--		변경될 떄마다 인덱스를 다시 계산하여 만들어야 한다.
--		성능이 저하될 수 있다.
--		인덱스 저장 위한 별도의 공간 필요


SELECT * FROM USER_IND_COLUMNS;

SELECT ROWID, EMP_ID, EMP_NAME
FROM EMPLOYEE;
--ROWID
--데이터의 순번. 오라클에서 테이블 생성, 데이터 추가시에 해당 객체들을 관리하기 위한 순번


--인덱스 생성
--SQL Error [1408] [72000]: ORA-01408: 열 목록에는 이미 인덱스가 작성되어 있습니다
CREATE UNIQUE INDEX IDX_EMP_NO
ON EMPLOYEE(EMP_NO);

--고유 인덱스
--	인덱스 생성시 고유값(유니크값)을 기준으로 생성하는 인덱스
--	오라클에서 자동으로 생성하는 인덱스
--	해당 컬럼을 SELECT문으로 조회할 때 포함시키면
--	조회할 때 고유인덱스를 이용해서 검색속도를 향상시킨다.

--비고유 인덱스(NOUNIQUE INDEX)
--내가 자주 사용하는 컬럼을 인덱스로 구성

SELECT EMP_NAME, DEPT_CODE, JOB_CODE
FROM EMPLOYEE WHERE DEPT_CODE = 'D6';
--0.003초 -> 0.002~0.001초

CREATE INDEX IDX_DEPT_CODE
ON EMPLOYEE(DEPT_CODE); --체감은 안되지만 아무튼 빠르게 검색할 수 있다.

--결합인덱스(COMPOSITE INDEX)
CREATE INDEX IDX_DEPT
ON DEPARTMENT(DEPT_ID,DEPT_TITLE);

SELECT * FROM DEPARTMENT;

--인덱스 새로고침
ALTER INDEX IDX_DEPT REBUILD;

--삭제
DROP INDEX IDX_DEPT;




--------------------------------------------------------
/*
 * ORACLE
 * DBMS
 * 데이터를 효율적으로 관리하기 위한 시스템
 * 
 * SQL
 * 	DDL : 데이터 정의어
 * 		CREATE, ALTER DROP
 * 
 * DML : 데이터 조작어
 * 		CRUD
 * 			CREATE	: INSERT
 * 			READ	: SELECT
 * 			UPDATE	: UPDATE
 * 			DELETE	: DELETE
 * 
 * DCL : 데이터 제어어
 * 		GRANT, REVOKE, COMMIT, ROLLBACK
 * 
 * 
 * SET OPERATOR
 * 		UNION, UNION ALL, INTERSECT, MINUS
 * 
 * 
 * JOIN
 * 		INNER JOIN : 두 개 이상의 테이블에서 같은 값끼리 묶어서 결과 셋을 만드는 방식
 * 					 작성된 조건이 일치하는 것만 처리
 * 
 * 		OUTER JOIN : 서로 다른 값도 포함하기 위해서 사용
 * 			LEFT, RIGHT, FULL
 * 
 * 
 * ORACLE 객체
 * 		USER, TABLE, VIEW, SEQUENCEC, INDEX
 * 			TABLE : 직사각형 표의 형태로 데이터를 저장하고 표현하는 데이터베이스 객체
 * 			VIEW : SELECT 쿼리를 저장하여, 필요 시 가져다 사용하는 가상의 테이블(편리성, 보안성)
 * 			SEQUENCE : 1,2,3,4...순서를 자동으로 증감시키는 데이터베이스 객체
 * 			INDEX : 테이블에서 데이터 검색 시 빠르게 검색하기 위한 객체
 * 
 * 
 * 
 * */


-- PL/SQL --
--[구성]
--DECLARE
--BEGIN
--EXCEPTION
--END;
--/

--프로시저 : PL/SQL을 미리 저장해 놓았다가 호출하여 함수처럼 동작시키는 객체
--[사용형식]
--CREATE [OR REPLACE] PROCEDURE 프로시저명(매개변수1 [IN/OUT/IN OUT] 자료형,...)
--										IN : 외부이서 값을 받아올 때 사용하는 모드
--										OUT : 프로시저 실행 결과를 외부로 추출
--IS
--	변수 선언
--BEGIN
--	실행할 스크립트;
--END;
--/

--[호출 방식]
--EXEC 프로시저명[(전달값...)]

--[삭제]
--DROP PROCEDURE 프로시저명;

--예시
--PL/SQL
DECLARE
	DUP_EMP_ID EXC EXCEPTION;
BEGIN
	UPDATE EMPLOYEE
	SET EMP_ID = '20000'
	WHERE EMP_ID='201'
EXCEPTION
	WHEN DUP_EMP_ID THEN DBMS_OUTPUT.PUT_LIE('이미 존재');
END;
/  --작동X 형식만 보세요


CREATE TABLE EMP_TMP
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_TMP;
--프로시저 생성
CREATE OR REPLACE PROCEDURE DEL_ALL_EMP
IS --변수 선언..
BEGIN
	DELETE FROM EMP_TMP;
	COMMIT;	
END;


SELECT COUNT(*) FROM EMP_TMP;

--실행
BEGIN
		DEL_ALL_EMP;
END;

--EXEC DEL_ALL_EMP;



----------------------
CREATE OR REPLACE FUNCTION BONUS_CAC(V_EMP_ID IN EMPLOYEE.EMP_ID%TYPE)
RETURN NUMBER
IS
	V_SAL EMPLOYEE.SALARY%TYPE;
	V_BONUS EMPLOYEE.SALARY%TYPE;
	RES NUMBER;
BEGIN
	SELECT SALARY, NVL(BONUS,0)
	INTO V_SAL, V_BONUS
	FROM EMPLOYEE
	WHERE EMPLOYEE.EMP_ID = V_EMP_ID;

	RES := V_SAL*V_BONUS;
	RETURN RES;
END;



SELECT EMP_NAME, BONUS_CAC(EMP_ID)
FROM EMPLOYEE;

SELECT EMP_NAME, SALARY, (SALARY+BONUS_CAC(EMP_ID))*12 연봉
FROM EMPLOYEE;




--TRIGGER 방아쇠
--특정 테입르에 DML을 통해서 데이터 변환이 일어날 때
--그걸 감지해서 자동으로 동작.

--테이블 생성
CREATE TABLE PRODUCT(
	PCODE NUMBER PRIMARY KEY,
	PNAME VARCHAR2(30),
	BRAND VARCHAR2(30),
	PRICE NUMBER,
	STICK NUMBER DEFAULT 0
);

--제품 입출고 내역 테이블
CREATE TABLE PRODUCT_DETAIL(
	DCODE NUMBER PRIMARY KEY,
	PCODE NUMBER NOT NULL,
	PDATE DATE DEFAULT SYSDATE,
	AMOUNT NUMBER,
	STATUS CHAR(6) CHECK(STATUS IN('입고','출고')),
	CONSTRAINT FK_PRODUCT FOREIGN KEY(PCODE) REFERENCES PRODUCT
);

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_DETAIL;


CREATE SEQUENCE SEQ_PRODUCT NOCACHE;
CREATE SEQUENCE SEQ_DETAIL NOCACHE;


--제품 등록
INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, '노트북','APPLE',2000000,DEFAULT);

INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, '핸드폰','삼성',1500000,DEFAULT);

INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, 'TV','LG',2500000,DEFAULT);

INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, '볼펜','모나미',2000000,DEFAULT);



SELECT * FROM PRODUCT;


--제품 입출고 관련 재고 증감 트리거
--DETAIL에 입출고가 된다면
--PRODUCT에 자동으로 재고값을 증가시킬거다.


SELECT * FROM USER_TRIGGERS;
DROP TRIGGER TRG_01;


CREATE OR REPLACE TRIGGER TRG_01
AFTER INSERT ON PRODUCT_DETAIL
FOR EACH ROW
BEGIN
	IF :NEW.STATUS = '입고'
	THEN
		UPDATE PRODUCT
		SET STICK = STICK + :NEW.AMOUNT
		WHERE PCODE= :NEW.PCODE;
	END IF;

	IF :NEW.STATUS='출고'
	THEN 
		UPDATE PRODUCT	
		SET STICK = STICK - :NEW.AMOUNT
		WHERE PCODE = :NEW.PCODE;
	END IF;
END;

INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 1, SYSDATE, 3,'입고');

SELECT * FROM PRODUCT_DETAIL;
SELECT * FROM PRODUCT;
-- 입고
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 2, SYSDATE, 100,'입고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 3, SYSDATE, 200,'입고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 4, SYSDATE, 1000,'입고');
-- 출고
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 1, SYSDATE, 1,'출고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 2, SYSDATE, 60,'출고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 3, SYSDATE, 30,'출고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 4, SYSDATE, 200,'출고');

