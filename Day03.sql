--DAY03 0609 월요일

--숫자 데이터 함수


--ABS() : 절댓값 표현
SELECT ABS(10), ABS(-10) FROM DUAL;


--MOD() : 주어진 컬럼이나 값을 나눈 나머지를 반환. 나머지.
SELECT MOD(10,3), MOD(10,6) ,(10/6) --몫을 알고 싶을 때 그냥 나누기 하면 됨. %는 사용 못함.
FROM DUAL;


--CEIL() : 소수점 첫째자리에서 올림
--FLOOR() : 소수점 버림
SELECT CEIL(123.456) , CEIL(123.678), CEIL(123),
	   FLOOR(123.456), FLOOR(123.678), FLOOR(123)
FROM DUAL;


--TRUNC() : 지정한 소수점 자리부터 버림.
SELECT TRUNC(123.456,0), TRUNC(123.456,1), TRUNC(123.456,2), TRUNC(123.456,-2)
FROM DUAL;


--EMPLOYEE 테이블에서 입사한 달이 홀수달인 사원들의 사번, 사원명, 입사일 조회
SELECT EMP_NO , EMP_NAME, HIRE_DATE FROM EMPLOYEE WHERE MOD(SUBSTR(HIRE_DATE,5,1),2) = 1;


--MONTHS_BETWEEN() : 두 날짜 사이의 개월 수
SELECT EMP_NAME, HIRE_DATE, TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE),0) FROM EMPLOYEE;


--NEXT_DAY
--앞으로 다가올 가장 가까운 요일을 반환
SELECT NEXT_DAY(SYSDATE, '토요일'),  NEXT_DAY(SYSDATE,'일'), NEXT_DAY(SYSDATE,6) --, NEXT_DAY(SYSDATE, 'SATURDAY') 언어설정이 한글이라 영어는 안먹힘,.;;
FROM DUAL;


SELECT * FROM V$NLS_PARAMETERS;
--현재 설정도니 정보를 테이블 형태로 보관 -> 이러한 테이블을 '데이터 사전(데이터 딕셔너리)'

SELECT * FROM TABS;


--LAST_DAY() : 해당 달의 마지막 날짜.
SELECT LAST_DAY(SYSDATE)
FROM DUAL;

--날짜값 끼리 +,- 연산 가능.
SELECT (SYSDATE - 10), (SYSDATE - TO_DATE('2022/03/01','RR/MM/DD')), (SYSDATE + 10)
FROM DUAL;

SELECT HIRE_DATE, (HIRE_DATE + 10)
FROM EMPLOYEE;



--
SELECT 
	SYSDATE,
	TO_CHAR(SYSDATE, 'RR/MM/DD'),
	TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS'),
	TO_CHAR(SYSDATE, 'YEAR, Q'), -- Q-> 분기. 
	TO_CHAR(SYSDATE, 'MON, YYYY')
FROM DUAL;


--연도
--Y/R
SELECT 
	TO_CHAR(TO_DATE('190325','YYMMDD'),'YYYY') "결과1",
	TO_CHAR(TO_DATE('190325','RRMMDD'),'RRRR') "결과2",
	TO_CHAR(TO_DATE('800325','YYMMDD'),'YYYY') "결과3",
	TO_CHAR(TO_DATE('800325','RRMMDD'),'RRRR') "결과4"
FROM DUAL;

--4자리 한번에 입력받을 때는 문제 안됨. 
--2자리 받는 경우
--YY=> 현 세기 기준으로 값을 추가.
--RR=> 반 세기

--RR 50~99 -> 1900년대
--	 00~49 -> 2000년대

--YY 
--80 -> 2080


--SELECT 문의 실행 순서
/*
--SELECT 컬럼 AS 별칭, 계산식, 함수
--FROM 테이블명 
--WHERE 조건
--GROUP BY 그룹을 묶을 컬럼명
--HAVING 그룹에 대한 조건식, 함수식
--ORDER BY 컬럼|별칭|순서 [ASC|DESC][, 컬럼명...]
*/


-- ORDER BY
SELECT EMP_ID, EMP_NAME 이름, SALARY, DEPT_CODE FROM EMPLOYEE
--ORDER BY 이름 DESC
ORDER BY 4 DESC, EMP_NAME;



--GROUP BY 그룹으로 묶는다.

--부서별 평균 급여--
--전체 사원의 급여 평균
SELECT TRUNC(AVG(SALARY),-3) FROM EMPLOYEE;

-- D1의 평균
SELECT TRUNC(AVG(SALARY),-3) 
FROM EMPLOYEE
WHERE DEPT_CODE  = 'D6';


--GROUP BY 절
--특정 컬럼 , 계산식을 기준으로 
--그룹별로 묶어 한 테이블 내에서 소그룹별로 조회하고자 할 때 선언하는 문구



SELECT TRUNC(AVG(SALARY),-3) 
FROM EMPLOYEE
GROUP BY DEPT_CODE;


--부서별 총 인원, 급여 합계, 급여 평균, 최대 급여, 최소 급여를 조회
--단, 부서코드 기준으로 오름차순
--급여 평균은 100의 자리 까지만 처리하고 나머지는 버림처리하자.

SELECT COUNT(*), SUM(SALARY), TRUNC(AVG(SALARY),-2), MAX(SALARY), MIN(SALARY) 
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE ;


--직급 코드 별 보너스 받는 사원의 수 조회
SELECT JOB_CODE, COUNT(BONUS)
FROM EMPLOYEE 
GROUP BY JOB_CODE
ORDER BY 1;


-- GROUP BY에서 주어진 컬럼 뿐만 아니라 함수식 사용 가능

SELECT DECODE(SUBSTR(EMP_NO,8,1),2,'여성','남성'),COUNT(*)
FROM EMPLOYEE
GROUP BY SUBSTR(EMP_NO,8,1);


-- 부서별 급여 평균을 구해서 조회
--단, 부서별 급여 평균이 300만원 이상인 부서만 조회
--HAVING <- 그룹에 대한 조건식. 이 친구 사용해야함.
SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE 
GROUP BY DEPT_CODE
HAVING AVG(SALARY) >= 3000000; --<- GROUP BY 한 각 소그룹에 대한 조건을 설정.


--부서별 그룹의 급여 합계 중 900만원을 초과하는 부서의 코드와 급여를 조회
SELECT DEPT_CODE, SUM(SALARY) 급여합계
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) > 9000000;


--급여 합계가 가장 높은 부서를 찾고 
--해당 부서의 부서 코드와 급여 합을 조회
--SELECT MAX(SUM(SALARY))
--FROM EMPLOYEE
--GROUP BY DEPT_CODE;

SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE 
HAVING SUM(SALARY) = (SELECT MAX(SUM(SALARY))FROM EMPLOYEE GROUP BY DEPT_CODE);


--
SELECT DEPT_CODE, JOB_CODE , SUM(SALARY) 
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE
ORDER BY 1;


--집계함수
--ROLLUP : 특정 그룹으로 묶은 뒤 해당 그룹의 총 합계를 자동으로 산출.
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE) --
ORDER BY 1,2;


--SET OPERATOR
--두개 이상의 SELECT 한 결과를 합치거나, 합칠 때 중복을 제거와 같은 
--집합 형태의 결과로 조회하는 명령어

--합집합
--UNION : 두 개 이상의 SELECT한 결과(ResultSet)를 구하는 명령어
--		만약 중복되는 경우 결과는 1번만 보여준다.
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE SALARY>3000000;

--UNION ALL : UNION과 동일. 단, 중복이 있어도 그대로 조회.
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE SALARY>3000000;

--교집합
--INTERSECT : 중복되는 결과만 보여준다.
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE SALARY>3000000;


--차집합
--MINUS : 가장 첫 결과에서 나머지 결과들과 일치하는 내용을 뺀 고유 결과를 조회
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID , EMP_NAME , DEPT_CODE , SALARY 
FROM EMPLOYEE
WHERE SALARY>3000000;


--[JOIN]--***
--두 개 이상의 테이블을 하나로 합쳐 조회하는데 사용하는 명령 구문

--J6라는 직급을 가진 사원들의 정보를 조회하는데 
--근무부서명이 궁금하다.

SELECT EMP_NAME, JOB_CODE, DEPT_CODE  
FROM EMPLOYEE 
WHERE JOB_CODE = 'J6';

SELECT  * FROM DEPARTMENT
WHERE DEPT_ID IN('D1','D8');

--오라클 전용 문법
--FROM 절에다가 ,로 구분하여 합치게 될 테이블을 나열.
--테이블을 엮는 기준으로 WHERE조건을 명시한다.
SELECT  EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE, DEPT_ID 
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID   --합쳐진 테이블에서 가져올 수 있다.
AND JOB_CODE = 'J6';

--표준 문법(MYSQL,등등...)
--FROM 절에는 기준이 되는 테이블만.
--FROM 다음에 JOIN 테이블명 ON() || USING구문 사용
SELECT  EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE, DEPT_ID 
FROM EMPLOYEE 
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID );
WHERE JOB_CODE = 'J6';


SELECT * FROM EMPLOYEE JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID ); --JOIN한 전체 테이	블


--두개의 테이블에서 공통 컬럼의 이름이 같은 경우
--EMPLOYEE테이블과 JOB테이블 JOIN
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;


--오라클 문법
SELECT EMP_ID, EMP_NAME, E.JOB_CODE, J.JOB_NAME
FROM EMPLOYEE e , JOB j 
WHERE E.JOB_CODE = J.JOB_CODE ;



--표준 문법
SELECT EMP_ID, EMP_NAME, EMPLOYEE.JOB_CODE, JOB.JOB_NAME
FROM EMPLOYEE JOIN JOB ON(EMPLOYEE.JOB_CODE = JOB.JOB_CODE );


SELECT EMP_ID, EMP_NAME, E.JOB_CODE, J.JOB_NAME
FROM EMPLOYEE E JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE );


SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE JOIN JOB USING(JOB_CODE);


SELECT * FROM EMPLOYEE JOIN JOB USING(JOB_CODE);


--사번, 사원명, 급여 등급(SAL_GRADE), 등급기준 최소 급여, 최대 급여
--EMPLOYEE테이블이랑
--SAL_GRADE테이블 합쳐서 
SELECT * FROM SAL_GRADE;
SELECT * FROM EMPLOYEE;

--표준 문법
SELECT EMP_NO, EMP_NAME, SAL_LEVEL, MIN_SAL, MAX_SAL
FROM EMPLOYEE JOIN SAL_GRADE USING (SAL_LEVEL);


--DEPARTMENT의 위치정보와
--LOCATION을 조인하여 
--각 부서별 근문지 위치를 조회.
--부서 코드, 부서명, 근무지 코드, 근무지 위치
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;

SELECT DEPT_ID, DEPT_TITLE, LOCAL_CODE, LOCAL_NAME
FROM DEPARTMENT D JOIN LOCATION L ON(D.LOCATION_ID = L.LOCAL_CODE);




--INNER JOIN/OUTER JOIN

--INNER JOIN : 둘 모두 일치하는 데이터만 합친다. 지금까지 작성했던 조인문.
--OUTER JOIN : 둘 모두, 둘 중 하나가 가진 데이터 합친다.하나만 있어도 합치겠다. 한쪽에만 있어도 남겨둔다, 살려둔다.

--INNER JOIN
SELECT DISTINCT DEPT_CODE, DEPT_TITLE  --DIESTINCT : 중복 제거
FROM EMPLOYEE JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

SELECT DISTINCT DEPT_CODE--DEPT_CODE와 DEPT_IDR가 같은게 없으면 출력되지 않는다. NULL인거도 사라져 있다.
FROM EMPLOYEE;


--OUTER JOIN
--	LEFT JOIN : 두 테이블 중 원본(왼쪽) 테이블의 정보를 모두 포함하여 조회 
--	RIGHT JOIN : 두 테이블 중 JOIN에 명시한 테이블의 정보를 모두 포함하여 조회
--	FULL JOIN : 두 테이블이 가진 데이터 중 서로가 가지지 않은 값일지라도 모두 포함하여 조회. 레프트 라이트 다 합친거.


--INNER
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID); --둘다 가지고 있는것만 (일치하는 것만) 출력

--LEFT
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE LEFT JOIN DEPARTMENT ON(DEPT_ID=DEPT_CODE);--EMPLOYEE의 DEPT_ID가 DEPARTMENT의 DEPT_CODE와 일치하지 않는 컬럼도 출력
--빈 칸은 NULL

--오라클 문법
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE , DEPARTMENT 
WHERE DEPT_CODE = DEPT_ID(+); --(+)넣으면 레프트 조인 가능.


--RIGHT
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE RIGHT JOIN DEPARTMENT ON(DEPT_ID=DEPT_CODE);

--오라클 문법
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE , DEPARTMENT 
WHERE DEPT_CODE(+) = DEPT_ID; --원본 테이블에(+)넣으면 라이트 조인 가능.


--FULL JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE FULL JOIN DEPARTMENT ON(DEPT_ID=DEPT_CODE);
--오라클 구문에서는 지원 안한다.

--추가적인 종류의 JOIN
--기본적인 조인은 양 테이블정보에서 하나씩은 일치하는 정보를 가지고 조인 수행.EQ(EQUAL) JOIN
--하지만, 서로 같은 값을 가지지 않은 테이블의 정보를 조회할 경우 CROSS JOIN을 통해 JON 수행

SELECT * FROM EMPLOYEE;
SELECT * FROM NATIONAL;

SELECT * FROM EMPLOYEE CROSS JOIN NATIONAL
ORDER BY 1; --로우 하나하나 다 결합되어 표현된다. 모든 로우들끼리 한번씩 다 합쳐진다.


-- NON-EQ JOIN
--특정 범위 내에 존재하는 조건으로 JOIN 수행

--ON() 안에 계산식, 함수식 .. 다양하게 작성 가능.

SELECT EMP_NAME, DEPT_CODE, SALARY, EMPLOYEE.SAL_LEVEL 
FROM EMPLOYEE JOIN SAL_GRADE ON(SALARY BETWEEN MIN_SAL AND MAX_SAL );


--SELF JOIN
--자기 자신을 JOIN하는 방법

--직원의 정보와 그 직원을 관리하는 매니저의 정보 조회
SELECT * FROM EMPLOYEE;

SELECT E.EMP_ID "사번", E.EMP_NAME "사원명", E.MANAGER_ID "관리자 사번", M.EMP_NAME "관리자명"
FROM EMPLOYEE E JOIN EMPLOYEE M ON(E.MANAGER_ID = M.EMP_ID);



--MULTIPLE JOIN 다중 JOIN
--여러개의 테이블을 JOIN한다.
--JOIN시 순서에 주의해서 작성해야한다.

SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME 
FROM EMPLOYEE 
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID )
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);


--ORACLE 구문
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME 
FROM EMPLOYEE, DEPARTMENT, LOCATION
WHERE DEPT_CODE = DEPT_ID
AND LOCATION_ID = LOCAL_CODE;



--한국(KO)과 일본(JP)에 근무하는 직원즐의 정보 조회
--사원명, 부서명, 지역명, 국가명
SELECT * FROM LOCATION;
SELECT * FROM NATIONAL;
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;

SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE 
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
JOIN NATIONAL ON(LOCATION.NATIONAL_CODE=NATIONAL.NATIONAL_CODE )
WHERE NATIONAL_NAME = '한국'
OR NATIONAL_NAME = '일본';


--문제2
--직급이 대리이면서, 아시아지역에 근무하는 사원 조회.
--사번, 사원명, 직급명, 부서명, 근무지역명, 급여
SELECT EMP_NO, EMP_NAME, JOB_NAME, DEPT_TITLE , LOCAL_NAME, SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN JOB USING(JOB_CODE)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
WHERE 
--LOCAL_NAME IN('ASIA1','ASIA2','ASIA3')
LOCAL_NAME LIKE 'ASIA%'
AND JOB_NAME = '대리';

--2방법 WOW!
SELECT EMP_NO, EMP_NAME, JOB_NAME, DEPT_TITLE , LOCAL_NAME, SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN JOB ON(EMPLOYEE.JOB_CODE=JOB.JOB_CODE AND JOB_NAME='대리')
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE AND LOCAL_NAME LIKE 'ASIA%');

--ORACLE 구문
SELECT EMP_NO, EMP_NAME, JOB_NAME, DEPT_TITLE , LOCAL_NAME, SALARY
FROM EMPLOYEE, DEPARTMENT, JOB, LOCATION
WHERE DEPT_CODE = DEPT_ID
AND EMPLOYEE.JOB_CODE=JOB.JOB_CODE AND JOB_NAME='대리'
AND EMPLOYEE.JOB_CODE=JOB.JOB_CODE AND JOB_NAME='대리'
AND LOCATION_ID = LOCAL_CODE AND LOCAL_NAME LIKE 'ASIA%';

SELECT * FROM EMPLOYEE LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--내일 
--SUBQUERY
--서브쿼리 쿼리 안의 쿼리.


SELECT * FROM employee;
SELECT * FROM DEPARTMENT;
SELECT * FROM mytest;




