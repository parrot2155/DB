--SUBQUERY--
--메인 쿼리 안에 또 다른 쿼리를 추가하는 기법

--EX) 최소 급여 받는 사원의 정보 조회

--최소 급여 확인
SELECT MIN(SALARY)
FROM EMPLOYEE;
--1380000

--사원정보 조회
SELECT * FROM EMPLOYEE WHERE SALARY = 1380000;

--단일행 서브쿼리 : 결과값 1개
SELECT * FROM EMPLOYEE WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);

--다중행 서브쿼리 : 결과값 여러개
--EX) 각 직급별  최소 급여 받는사람
SELECT MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE;
SELECT * FROM EMPLOYEE WHERE SALARY IN (SELECT MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE);

--다중행 다중열 서브쿼리
SELECT JOB_CODE, MIN(SALARY)
FROM EMPLOYEE GROUP BY JOB_CODE;

SELECT * FROM EMPLOYEE 
WHERE (JOB_CODE , SALARY) IN(SELECT JOB_CODE, MIN(SALARY) --비교할 값 두개 모두 조건처리.
		FROM EMPLOYEE GROUP BY JOB_CODE);


--서브쿼리 사용 위치
--SELECT , FROM , WHERE , GROUP BY, HAVING, ORDER BY, JOIN
--DML : INSERT, UPDATE, DELETE
--DDL : CREATE TABLE, CREATE VIEW
--DCL제외하고 왠만한 곳에서 다 쓸수 있다.

--FROM 위치에 사용되는 서브쿼리
--인라인뷰(Inline View)
--테이블 명으로 직접 조회하는 대신 서브쿼리의 결과(RESULT SET)를 활용해 조회

 SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME
 FROM EMPLOYEE
 JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
 JOIN JOB USING(JOB_CODE);

SELECT * FROM (SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME
			   FROM EMPLOYEE
			   JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
			   JOIN JOB USING(JOB_CODE));


--ROWNUM : 데이터 조회 시 각 행의 번호를 매겨주는 함수
SELECT ROWNUM, EMP_NAME, SALARY
FROM EMPLOYEE;

SELECT ROWNUM, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE ROWNUM < 6;

--급여 기준으로 가장 높은 급여를 받는 사원
--상위 5명 조회
--사번, 사원명, 급여
SELECT ROWNUM , EMP_ID , EMP_NAME , SALARY FROM EMPLOYEE ORDER BY SALARY ;
--ROWNUM은 FROM에서 이미 번호가 매겨짐.
SELECT ROWNUM , EMP_ID , EMP_NAME , SALARY FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC) WHERE ROWNUM<6;


--급여 평균 상위3개 부서 조회
SELECT DEPT_CODE , DEPT_TITLE , TRUNC(AVG(SALARY),-3) 평균
FROM EMPLOYEE ,DEPARTMENT 
WHERE DEPT_CODE = DEPT_ID 
GROUP BY DEPT_CODE, DEPT_TITLE
ORDER BY 3 DESC;

SELECT ROWNUM , DEPT_CODE , DEPT_TITLE , 평균
FROM (SELECT DEPT_CODE , DEPT_TITLE , TRUNC(AVG(SALARY),-3) 평균
	  FROM EMPLOYEE ,DEPARTMENT 
	  WHERE DEPT_CODE = DEPT_ID 
	  GROUP BY DEPT_CODE, DEPT_TITLE
	  ORDER BY 3 DESC)
WHERE ROWNUM < 4;

--RANK()함수 , DENSE_RANK()함수

--RANK() : 동일 순번 이후 순번에 영향 있다.
SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE;
		
SELECT * FROM (SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE) WHERE 순위 < 4;

--DENSE_RANK() : 동일한 순번 있을 경우 이후 순번에 영향 없다.
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE; 
SELECT * FROM (SELECT EMP_NAME, SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE) WHERE 순위 < 4;

--문제 1
--부서별 급여 합계가 전체 부서 급여 총합의 20%보다 많이 받는 부서의
--부서명, 부서 급여 합계 조회

--HINT: HAVING, 전체급여 합계의 20% 조회하는 서브쿼리
--1)
SELECT SUM(SALARY)*0.2
FROM EMPLOYEE;

SELECT DEPT_CODE, SUM(SALARY) 
FROM (EMPLOYEE) 
GROUP BY DEPT_CODE 
HAVING SUM(SALARY)>(SELECT SUM(SALARY)*0.2 FROM EMPLOYEE);

--2)
--인라인뷰
SELECT * FROM (SELECT DEPT_CODE, SUM(SALARY) SUMSAL FROM EMPLOYEE GROUP BY DEPT_CODE)
WHERE SUMSAL > (SELECT SUM(SALARY)*0.2 FROM EMPLOYEE);

--상호연관 쿼리(상관쿼리)
--메인 쿼리의 컬럼을 서브쿼리에도 적용하여 사용하는 서브쿼리문
--사원의 직급에 따른 급여 평균보다 많이 받는 사원의 정보를 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE E1
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E1.JOB_CODE = E2.JOB_CODE);



--단일행 서브쿼리 + 상관쿼리 = 스칼라 서브쿼리
--모든 사원의 사번, 사원명, 관리자 사번, 관리자명을 조회
--단, 고나리자가 없을 경우 '없음'이라고 표시
SELECT EMP_ID, EMP_NAME, MANAGER_ID , NVL((SELECT EMP_NAME FROM EMPLOYEE E2 WHERE E1.MANAGER_ID = E2.EMP_ID), '없음') "관리자 이름"
FROM EMPLOYEE E1;








