--SUBQUERY--
--메인 쿼리 안에 또 다른 쿼리를 추가하는 기법

--EX) 최소 급여 받는 사원의 정보 조회

--최소 급여 확인
SELECT MIN(SALARY)
FROM EMPLOYEE;
--1380000

--사원정보 조회
SELECT * FROM EMPLOYEE WHERE SALARY = 1380000;

--단일행 서브쿼리 : 결과값 1개
SELECT * FROM EMPLOYEE WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);

--다중행 서브쿼리 : 결과값 여러개
--EX) 각 직급별  최소 급여 받는사람
SELECT MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE;
SELECT * FROM EMPLOYEE WHERE SALARY IN (SELECT MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE);

--다중행 다중열 서브쿼리
SELECT JOB_CODE, MIN(SALARY)
FROM EMPLOYEE GROUP BY JOB_CODE;

SELECT * FROM EMPLOYEE 
WHERE (JOB_CODE , SALARY) IN(SELECT JOB_CODE, MIN(SALARY) --비교할 값 두개 모두 조건처리.
		FROM EMPLOYEE GROUP BY JOB_CODE);


--서브쿼리 사용 위치
--SELECT , FROM , WHERE , GROUP BY, HAVING, ORDER BY, JOIN
--DML : INSERT, UPDATE, DELETE
--DDL : CREATE TABLE, CREATE VIEW
--DCL제외하고 왠만한 곳에서 다 쓸수 있다.

--FROM 위치에 사용되는 서브쿼리
--인라인뷰(Inline View)
--테이블 명으로 직접 조회하는 대신 서브쿼리의 결과(RESULT SET)를 활용해 조회

 SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME
 FROM EMPLOYEE
 JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
 JOIN JOB USING(JOB_CODE);

SELECT * FROM (SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME
			   FROM EMPLOYEE
			   JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
			   JOIN JOB USING(JOB_CODE));


--ROWNUM : 데이터 조회 시 각 행의 번호를 매겨주는 함수
SELECT ROWNUM, EMP_NAME, SALARY
FROM EMPLOYEE;

SELECT ROWNUM, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE ROWNUM < 6;

--급여 기준으로 가장 높은 급여를 받는 사원
--상위 5명 조회
--사번, 사원명, 급여
SELECT ROWNUM , EMP_ID , EMP_NAME , SALARY FROM EMPLOYEE ORDER BY SALARY ;
--ROWNUM은 FROM에서 이미 번호가 매겨짐.
SELECT ROWNUM , EMP_ID , EMP_NAME , SALARY FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC) WHERE ROWNUM<6;


--급여 평균 상위3개 부서 조회
SELECT DEPT_CODE , DEPT_TITLE , TRUNC(AVG(SALARY),-3) 평균
FROM EMPLOYEE ,DEPARTMENT 
WHERE DEPT_CODE = DEPT_ID 
GROUP BY DEPT_CODE, DEPT_TITLE
ORDER BY 3 DESC;

SELECT ROWNUM , DEPT_CODE , DEPT_TITLE , 평균
FROM (SELECT DEPT_CODE , DEPT_TITLE , TRUNC(AVG(SALARY),-3) 평균
	  FROM EMPLOYEE ,DEPARTMENT 
	  WHERE DEPT_CODE = DEPT_ID 
	  GROUP BY DEPT_CODE, DEPT_TITLE
	  ORDER BY 3 DESC)
WHERE ROWNUM < 4;

--RANK()함수 , DENSE_RANK()함수

--RANK() : 동일 순번 이후 순번에 영향 있다.
SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE;
		
SELECT * FROM (SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE) WHERE 순위 < 4;

--DENSE_RANK() : 동일한 순번 있을 경우 이후 순번에 영향 없다.
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE; 
SELECT * FROM (SELECT EMP_NAME, SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) 순위 FROM EMPLOYEE) WHERE 순위 < 4;

--문제 1
--부서별 급여 합계가 전체 부서 급여 총합의 20%보다 많이 받는 부서의
--부서명, 부서 급여 합계 조회

--HINT: HAVING, 전체급여 합계의 20% 조회하는 서브쿼리
--1)
SELECT SUM(SALARY)*0.2
FROM EMPLOYEE;

SELECT DEPT_CODE, SUM(SALARY) 
FROM (EMPLOYEE) 
GROUP BY DEPT_CODE 
HAVING SUM(SALARY)>(SELECT SUM(SALARY)*0.2 FROM EMPLOYEE);

--2)
--인라인뷰
SELECT * FROM (SELECT DEPT_CODE, SUM(SALARY) SUMSAL FROM EMPLOYEE GROUP BY DEPT_CODE)
WHERE SUMSAL > (SELECT SUM(SALARY)*0.2 FROM EMPLOYEE);

--상호연관 쿼리(상관쿼리)
--메인 쿼리의 컬럼을 서브쿼리에도 적용하여 사용하는 서브쿼리문
--사원의 직급에 따른 급여 평균보다 많이 받는 사원의 정보를 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE E1
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E1.JOB_CODE = E2.JOB_CODE);



--단일행 서브쿼리 + 상관쿼리 = 스칼라 서브쿼리
--모든 사원의 사번, 사원명, 관리자 사번, 관리자명을 조회
--단, 고나리자가 없을 경우 '없음'이라고 표시
SELECT EMP_ID, EMP_NAME, MANAGER_ID , NVL((SELECT EMP_NAME FROM EMPLOYEE E2 WHERE E1.MANAGER_ID = E2.EMP_ID), '없음') "관리자 이름"
FROM EMPLOYEE E1;


--자신이 속한 직급의 평균 급여보다 많이 받는 사원
--이름, 직급명, 급여정보 조회

SELECT AVG(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE;

SELECT EMP_NAME, JOB_NAME, SALARY 
FROM EMPLOYEE E1
JOIN JOB J ON(E1.JOB_CODE = J.JOB_CODE) 
WHERE SALARY>(
	SELECT AVG(E2.SALARY) 
	FROM EMPLOYEE E2
	WHERE (E1.JOB_CODE = E2.JOB_CODE));
	

--DDL
/*
 * CREATE : 데이터베이스에서 객체를 생성하는 DDL
 * 
 * CREATE 객체종류 객체명(생성시 관련내용)
 * 
 * --계정 만든다.
 * CREATE USER MULTI...
 * 
 * --테이블 만든다
 *CREATE TABLE TEST...
 *
 *CREATE TABLE 테이블명( 컬럼명 자료형(길이) 제약조건,...)
 *
 *
 *제약조건 : 테이블에 데이터를 저장하고자 할 떄 지켜야할 규칙, 제약
 *
 *NOT NULL	- NULL값 허용하지 않는다.(필수 입력사항.)
 *UNIQUE	- 중복값 허용하지 않는다.
 *CHECK		- 지정한 입력값 외에는 저장하지 못하게 막는 조건
 *PRIMARY KEY - (NOT NULL + UNIQUE) 기본 키
 *				테이블 내에서 행을(데이터, 로우)를 구분할 수 있는 고유 값.
 *				테이블 안에 하나의 커럼만 선언 가능.
 *FOREIGN KEY - 외래 키
 *				다른 테이블에서 저장된 값을 연결지어 참조로 가져오는 데이터에 지정하는 제약조건.
 *
 */
--테이블 생성
CREATE TABLE MEMBER(
	MEMBER_NO NUMBER,
	MEMBER_ID VARCHAR2(20),
	MEMBER_PWD VARCHAR2(20),
	MEMBER_NAME VARCHAR2(20)
);

SELECT * FROM MEMBER;

--현재 접속한 사용자(USER,계정)이 보유한 테이블 목록
--데이터 사전
SELECT * FROM USER_TABLES;

SELECT * FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'MEMBER';

SELECT * FROM USER_CONSTRAINTS;

--제약조건(CONSTRAINTS)--
--테이블 생성 시 각 컬럼에 값을 저장하는 것에 대한 제약사항을 설정할 때 사용하는 조건들
--데이터 무결성 보장(데이터가 정확하고, 일관되고, 유효하다)보장

--NOT NULL
--'NULL 값을 허용하지 않는다.'
--반드시 값을 저장해야 하는 컬럼인 경우 제약조건 추가

CREATE TABLE USER_NONCONS(
	NO NUMBER,
	ID VARCHAR(20),
	PW VARCHAR(20),
	NAME VARCHAR2(20),
	GENDER VARCHAR(3)
);

SELECT *  FROM USER_NONCONS;

--테이블에 값 추가 DML에서 INSERT
INSERT INTO USER_NONCONS(NO,ID,PW,NAME,GENDER)
VALUES(1,'USER01','PASS01','홍길동','남');

--데이터 추가 후 조회
SELECT *  FROM USER_NONCONS; 

INSERT INTO USER_NONCONS
VALUES(2,NULL,NULL,NULL,'여');


--NOT NULL 제약 조건 추가하여 확인
CREATE TABLE USER_NOT_NULL(
	NO NUMBER,
	
);


















